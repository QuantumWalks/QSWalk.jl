<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Demoralization · QSWalk</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QSWalk logo"/></a><div class="docs-package-name"><span class="docs-autofit">QSWalk</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gksl/">GKSL master equation</a></li><li class="is-active"><a class="tocitem" href>Demoralization</a><ul class="internal"><li><a class="tocitem" href="#Nonmoralizing-model-1"><span>Nonmoralizing model</span></a></li><li><a class="tocitem" href="#Full-docs-1"><span>Full docs</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../citing/">Citing</a></li><li><a class="tocitem" href="../license/">Licence</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Demoralization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Demoralization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/iitis/QSWalk.jl/blob/master/docs/src/demoralization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Nonmoralizing-model-1"><a class="docs-heading-anchor" href="#Nonmoralizing-model-1">Nonmoralizing model</a><a class="docs-heading-anchor-permalink" href="#Nonmoralizing-model-1" title="Permalink"></a></h2><p>Global interaction quantum stochastic walk suffers from creating additional connections. This renders it unsuitable for constructing fast quantum walks on directed graphs. To counteract this effect, the nonmoralizing quantum stochastic walk was introduced (see <a href="https://arxiv.org/abs/1701.04624">arXiv preprint</a> and <a href="http://www.rintonpress.com/journals/qiconline.html#v17n1112">its published version</a>). Such a model is constructed in several steps. First, the dimensionality of the system is increased by attaching a multidimensional subspace to each vertex. Next, the Hamiltonian and the Lindblad operators are modified, and an additional Hamiltonian - so-called <em>local Hamiltonian</em> - is introduced.</p><p><em>Please note that current definition of <code>nm_glob_ham</code> differs from the one presented in the paper.</em></p><p>Below we present additional functionality useful for analyzing nonmoralizing quantum stochastic walk. By default, the operator is generalized as in the original <a href="http://www.rintonpress.com/journals/qiconline.html#v17n1112">paper</a>.</p><ul><li><a href="#QSWalk.Vertex"><code>QSWalk.Vertex</code></a></li><li><a href="#QSWalk.VertexSet"><code>QSWalk.VertexSet</code></a></li><li><a href="#QSWalk.default_nm_loc_ham"><code>QSWalk.default_nm_loc_ham</code></a></li><li><a href="#QSWalk.fourier_matrix"><code>QSWalk.fourier_matrix</code></a></li><li><a href="#QSWalk.make_vertex_set"><code>QSWalk.make_vertex_set</code></a></li><li><a href="#QSWalk.nm_glob_ham"><code>QSWalk.nm_glob_ham</code></a></li><li><a href="#QSWalk.nm_init"><code>QSWalk.nm_init</code></a></li><li><a href="#QSWalk.nm_lind"><code>QSWalk.nm_lind</code></a></li><li><a href="#QSWalk.nm_loc_ham"><code>QSWalk.nm_loc_ham</code></a></li><li><a href="#QSWalk.nm_measurement"><code>QSWalk.nm_measurement</code></a></li><li><a href="#QSWalk.subspace"><code>QSWalk.subspace</code></a></li><li><a href="#QSWalk.vertexsetsize"><code>QSWalk.vertexsetsize</code></a></li><li><a href="#QSWalk.vlist"><code>QSWalk.vlist</code></a></li></ul><h2 id="Full-docs-1"><a class="docs-heading-anchor" href="#Full-docs-1">Full docs</a><a class="docs-heading-anchor-permalink" href="#Full-docs-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QSWalk.Vertex" href="#QSWalk.Vertex"><code>QSWalk.Vertex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">type Vertex</code></pre><p>Type consisting of list of <code>Int</code>, describing the labels of vectors from the canonical basis corresponding to the <code>Vertex</code>. To get the vector label one can use <code>Vertex()</code> function, or <code>Vertex[i]</code> for a unique label.</p><p>See [1] for the more information and usage exmaples.</p><p>[1] K. Domino, A. Glos, M. Ostaszewski, Superdiffusive quantum stochastic walk definable on arbitrary directed graph, Quantum Information &amp; Computation, Vol.17 No.11&amp;12, pp. 0973-0986, arXiv:1701.04624.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/utils.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.VertexSet" href="#QSWalk.VertexSet"><code>QSWalk.VertexSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">type VertexSet</code></pre><p>Type consisting of a list of <code>Vertex</code> objects. It describes the partition of the linear subspace. Object of this type should be constructed using <code>make_vertex_set</code> or by <code>nm_lind</code> functions. In order to get a list of the vertices from an object of type <code>vertexset</code>, one should use <code>vlist</code> function, or, for a specific <code>Vertex</code>, an getindex function <code>vertexset[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/utils.jl#L86-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.nm_glob_ham" href="#QSWalk.nm_glob_ham"><code>QSWalk.nm_glob_ham</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nm_glob_ham(A[, hamiltonians][, weights, epsilon])</code></pre><p>Return global Hamiltonian for the moralization procedure. Matrix <code>A</code> should the adjacency matrix of a directed graph, for which one aims to construct the nonmoralizing dynamics. Here, <code>hamiltonians</code> is an optional argument which is a Dictionary with keys of type <code>Tuple{Int, Int}</code> or <code>Tuple{Vertex, Vertex}</code>. The first collects the submatrices according to their shape, while the second collects them according to each pair of vertices. As the default all-one submatrices are chosen. The last argument states that only those elements for which <code>abs(A[i, j]) &gt;= epsilon</code> are considered.</p><p><em>Note:</em> The submatrices of the result matrix are scaled by corresponding <code>weights</code> argument, which should be a square matrix of the same dimension as <code>A</code>. If <code>weights</code> is not provided, then <code>weights[i,j]=A[i,j]</code>, if <code>A[i,j]</code> is nonzero and <code>A[j,i]</code> is zero, <code>weights[i,j]=A[j,i]</code>, if <code>A[i,j]</code> in reverse scenario, <code>weights[i,j]=(A[i,j]+A[j,i])/2</code> if both are nonzero, and zero otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [ 0 1 0; 1 0 1; 0 1 0]
3×3 Array{Int64,2}:
 0  1  0
 1  0  1
 0  1  0

julia&gt; nm_glob_ham(A) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im  1.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  1.0+0.0im  1.0+0.0im  0.0+0.0im

julia&gt; dict_deg = Dict{Tuple{Int,Int},Matrix{ComplexF64}}((1, 2) =&gt; (2+1im)*ones(1, 2), (2, 1) =&gt;1im*ones(2, 1));

julia&gt; nm_glob_ham(A, dict_deg) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  2.0+1.0im  2.0+1.0im  0.0+0.0im
 2.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 2.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 0.0+0.0im  0.0-1.0im  0.0-1.0im  0.0+0.0im

julia&gt; v1, v2, v3 = vlist(make_vertex_set(A))
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])

julia&gt; dict_vec = Dict{Tuple{Vertex,Vertex},Matrix{ComplexF64}}((v1, v2) =&gt;2*ones(1, 2), (v2, v3) =&gt;[1im 2im;]&#39;);

julia&gt; nm_glob_ham(A, dict_vec) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  2.0+0.0im  2.0+0.0im  0.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-2.0im
 0.0+0.0im  0.0+1.0im  0.0+2.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L276-L335">source</a></section><section><div><pre><code class="language-julia">nm_glob_ham(A[, hamiltonians][, weights, epsilon])</code></pre><p>Return global Hamiltonian for the moralization procedure. Matrix <code>A</code> should the adjacency matrix of a directed graph, for which one aims to construct the nonmoralizing dynamics. Here, <code>hamiltonians</code> is an optional argument which is a Dictionary with keys of type <code>Tuple{Int, Int}</code> or <code>Tuple{Vertex, Vertex}</code>. The first collects the submatrices according to their shape, while the second collects them according to each pair of vertices. As the default all-one submatrices are chosen. The last argument states that only those elements for which <code>abs(A[i, j]) &gt;= epsilon</code> are considered.</p><p><em>Note:</em> The submatrices of the result matrix are scaled by corresponding <code>weights</code> argument, which should be a square matrix of the same dimension as <code>A</code>. If <code>weights</code> is not provided, then <code>weights[i,j]=A[i,j]</code>, if <code>A[i,j]</code> is nonzero and <code>A[j,i]</code> is zero, <code>weights[i,j]=A[j,i]</code>, if <code>A[i,j]</code> in reverse scenario, <code>weights[i,j]=(A[i,j]+A[j,i])/2</code> if both are nonzero, and zero otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [ 0 1 0; 1 0 1; 0 1 0]
3×3 Array{Int64,2}:
 0  1  0
 1  0  1
 0  1  0

julia&gt; nm_glob_ham(A) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im  1.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  1.0+0.0im  1.0+0.0im  0.0+0.0im

julia&gt; dict_deg = Dict{Tuple{Int,Int},Matrix{ComplexF64}}((1, 2) =&gt; (2+1im)*ones(1, 2), (2, 1) =&gt;1im*ones(2, 1));

julia&gt; nm_glob_ham(A, dict_deg) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  2.0+1.0im  2.0+1.0im  0.0+0.0im
 2.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 2.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 0.0+0.0im  0.0-1.0im  0.0-1.0im  0.0+0.0im

julia&gt; v1, v2, v3 = vlist(make_vertex_set(A))
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])

julia&gt; dict_vec = Dict{Tuple{Vertex,Vertex},Matrix{ComplexF64}}((v1, v2) =&gt;2*ones(1, 2), (v2, v3) =&gt;[1im 2im;]&#39;);

julia&gt; nm_glob_ham(A, dict_vec) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  2.0+0.0im  2.0+0.0im  0.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-2.0im
 0.0+0.0im  0.0+1.0im  0.0+2.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L276-L335">source</a></section><section><div><pre><code class="language-julia">nm_glob_ham(A[, hamiltonians][, weights, epsilon])</code></pre><p>Return global Hamiltonian for the moralization procedure. Matrix <code>A</code> should the adjacency matrix of a directed graph, for which one aims to construct the nonmoralizing dynamics. Here, <code>hamiltonians</code> is an optional argument which is a Dictionary with keys of type <code>Tuple{Int, Int}</code> or <code>Tuple{Vertex, Vertex}</code>. The first collects the submatrices according to their shape, while the second collects them according to each pair of vertices. As the default all-one submatrices are chosen. The last argument states that only those elements for which <code>abs(A[i, j]) &gt;= epsilon</code> are considered.</p><p><em>Note:</em> The submatrices of the result matrix are scaled by corresponding <code>weights</code> argument, which should be a square matrix of the same dimension as <code>A</code>. If <code>weights</code> is not provided, then <code>weights[i,j]=A[i,j]</code>, if <code>A[i,j]</code> is nonzero and <code>A[j,i]</code> is zero, <code>weights[i,j]=A[j,i]</code>, if <code>A[i,j]</code> in reverse scenario, <code>weights[i,j]=(A[i,j]+A[j,i])/2</code> if both are nonzero, and zero otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [ 0 1 0; 1 0 1; 0 1 0]
3×3 Array{Int64,2}:
 0  1  0
 1  0  1
 0  1  0

julia&gt; nm_glob_ham(A) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im  1.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  1.0+0.0im  1.0+0.0im  0.0+0.0im

julia&gt; dict_deg = Dict{Tuple{Int,Int},Matrix{ComplexF64}}((1, 2) =&gt; (2+1im)*ones(1, 2), (2, 1) =&gt;1im*ones(2, 1));

julia&gt; nm_glob_ham(A, dict_deg) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  2.0+1.0im  2.0+1.0im  0.0+0.0im
 2.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 2.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 0.0+0.0im  0.0-1.0im  0.0-1.0im  0.0+0.0im

julia&gt; v1, v2, v3 = vlist(make_vertex_set(A))
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])

julia&gt; dict_vec = Dict{Tuple{Vertex,Vertex},Matrix{ComplexF64}}((v1, v2) =&gt;2*ones(1, 2), (v2, v3) =&gt;[1im 2im;]&#39;);

julia&gt; nm_glob_ham(A, dict_vec) |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  2.0+0.0im  2.0+0.0im  0.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-1.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  0.0-2.0im
 0.0+0.0im  0.0+1.0im  0.0+2.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L276-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.nm_lind" href="#QSWalk.nm_lind"><code>QSWalk.nm_lind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nm_lind(A[, lindbladians][, epsilon])</code></pre><p>Return single Lindbladian operator and a vertex set describing how vertices are bound to subspaces. The operator is constructed according to the corection scheme presented in [1]. Parameter <code>A</code> is a square matrix, describing the connection between the canonical subspaces in a similar manner as the adjacency matrix. Parameter <code>epsilon</code>, with the default value <code>eps()</code>, determines the relevant values by <code>abs(A[i, j]) &gt;=  epsilon</code> formula. List <code>lindbladians</code> describes the elementary matrices used. It can be <code>Dict{Int, SparseDenseMatrix}</code>, which returns the matrix by the indegree, or <code>Dict{Vertex, SparseDenseMatrix}</code> which, for different vertices, may return different matrix. The matrix should have orthogonal columns and be of the size outdeg of the vertex. As default the function uses Fourier matrices.</p><p><em>Note:</em> It is expected that for all pair of vertices there exists a matrix in the <code>lindbladians</code> list.</p><p><em>Note:</em> The orthogonality of matrices in <code>lindbladians</code> is not verified.</p><p><em>Note:</em> The submatrices of the result matrix are multiplied by corresponding <code>A</code> element.</p><p>[1] K. Domino, A. Glos, M. Ostaszewski, Superdiffusive quantum stochastic walk definable on arbitrary directed graph, Quantum Information &amp; Computation, Vol.17 No.11&amp;12, pp. 0973-0986, arXiv:1701.04624.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 1 0; 1 0 1; 0 1 0]
3×3 Array{Int64,2}:
 0  1  0
 1  0  1
 0  1  0

julia&gt; L, vset = nm_lind(A)
(
  [2, 1]  =  1.0+0.0im
  [3, 1]  =  1.0+0.0im
  [1, 2]  =  1.0+0.0im
  [4, 2]  =  1.0+0.0im
  [1, 3]  =  1.0+0.0im
  [4, 3]  =  1.0+0.0im
  [2, 4]  =  1.0+0.0im
  [3, 4]  =  -1.0+1.22465e-16im, VertexSet(Vertex[Vertex([1]), Vertex([2, 3]), Vertex([4])]))

julia&gt; B1, B2 = 2*diagm(0=&gt;[1.]), 3*ones(2, 2)
([2.0], [3.0 3.0; 3.0 3.0])

julia&gt; nm_lind(A, Dict{Int,Matrix{Float64}}(1=&gt;B1, 2=&gt;B2))
(
  [2, 1]  =  3.0+0.0im
  [3, 1]  =  3.0+0.0im
  [1, 2]  =  2.0+0.0im
  [4, 2]  =  2.0+0.0im
  [1, 3]  =  2.0+0.0im
  [4, 3]  =  2.0+0.0im
  [2, 4]  =  3.0+0.0im
  [3, 4]  =  3.0+0.0im, VertexSet(Vertex[Vertex([1]), Vertex([2, 3]), Vertex([4])]))

julia&gt; v1, v2, v3 = vlist(vset)
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])

julia&gt; nm_lind(A, Dict{Vertex,Matrix{Float64}}(v1 =&gt; ones(1, 1), v2 =&gt; [2 2; 2 -2], v3 =&gt; 3*ones(1, 1)))[1] |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im  1.0+0.0im   0.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im   2.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im
 0.0+0.0im  3.0+0.0im  3.0+0.0im   0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L155-L230">source</a></section><section><div><pre><code class="language-julia">nm_lind(A[, lindbladians][, epsilon])</code></pre><p>Return single Lindbladian operator and a vertex set describing how vertices are bound to subspaces. The operator is constructed according to the corection scheme presented in [1]. Parameter <code>A</code> is a square matrix, describing the connection between the canonical subspaces in a similar manner as the adjacency matrix. Parameter <code>epsilon</code>, with the default value <code>eps()</code>, determines the relevant values by <code>abs(A[i, j]) &gt;=  epsilon</code> formula. List <code>lindbladians</code> describes the elementary matrices used. It can be <code>Dict{Int, SparseDenseMatrix}</code>, which returns the matrix by the indegree, or <code>Dict{Vertex, SparseDenseMatrix}</code> which, for different vertices, may return different matrix. The matrix should have orthogonal columns and be of the size outdeg of the vertex. As default the function uses Fourier matrices.</p><p><em>Note:</em> It is expected that for all pair of vertices there exists a matrix in the <code>lindbladians</code> list.</p><p><em>Note:</em> The orthogonality of matrices in <code>lindbladians</code> is not verified.</p><p><em>Note:</em> The submatrices of the result matrix are multiplied by corresponding <code>A</code> element.</p><p>[1] K. Domino, A. Glos, M. Ostaszewski, Superdiffusive quantum stochastic walk definable on arbitrary directed graph, Quantum Information &amp; Computation, Vol.17 No.11&amp;12, pp. 0973-0986, arXiv:1701.04624.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 1 0; 1 0 1; 0 1 0]
3×3 Array{Int64,2}:
 0  1  0
 1  0  1
 0  1  0

julia&gt; L, vset = nm_lind(A)
(
  [2, 1]  =  1.0+0.0im
  [3, 1]  =  1.0+0.0im
  [1, 2]  =  1.0+0.0im
  [4, 2]  =  1.0+0.0im
  [1, 3]  =  1.0+0.0im
  [4, 3]  =  1.0+0.0im
  [2, 4]  =  1.0+0.0im
  [3, 4]  =  -1.0+1.22465e-16im, VertexSet(Vertex[Vertex([1]), Vertex([2, 3]), Vertex([4])]))

julia&gt; B1, B2 = 2*diagm(0=&gt;[1.]), 3*ones(2, 2)
([2.0], [3.0 3.0; 3.0 3.0])

julia&gt; nm_lind(A, Dict{Int,Matrix{Float64}}(1=&gt;B1, 2=&gt;B2))
(
  [2, 1]  =  3.0+0.0im
  [3, 1]  =  3.0+0.0im
  [1, 2]  =  2.0+0.0im
  [4, 2]  =  2.0+0.0im
  [1, 3]  =  2.0+0.0im
  [4, 3]  =  2.0+0.0im
  [2, 4]  =  3.0+0.0im
  [3, 4]  =  3.0+0.0im, VertexSet(Vertex[Vertex([1]), Vertex([2, 3]), Vertex([4])]))

julia&gt; v1, v2, v3 = vlist(vset)
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])

julia&gt; nm_lind(A, Dict{Vertex,Matrix{Float64}}(v1 =&gt; ones(1, 1), v2 =&gt; [2 2; 2 -2], v3 =&gt; 3*ones(1, 1)))[1] |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im  1.0+0.0im   0.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im   2.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im
 0.0+0.0im  3.0+0.0im  3.0+0.0im   0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L155-L230">source</a></section><section><div><pre><code class="language-julia">nm_lind(A[, lindbladians][, epsilon])</code></pre><p>Return single Lindbladian operator and a vertex set describing how vertices are bound to subspaces. The operator is constructed according to the corection scheme presented in [1]. Parameter <code>A</code> is a square matrix, describing the connection between the canonical subspaces in a similar manner as the adjacency matrix. Parameter <code>epsilon</code>, with the default value <code>eps()</code>, determines the relevant values by <code>abs(A[i, j]) &gt;=  epsilon</code> formula. List <code>lindbladians</code> describes the elementary matrices used. It can be <code>Dict{Int, SparseDenseMatrix}</code>, which returns the matrix by the indegree, or <code>Dict{Vertex, SparseDenseMatrix}</code> which, for different vertices, may return different matrix. The matrix should have orthogonal columns and be of the size outdeg of the vertex. As default the function uses Fourier matrices.</p><p><em>Note:</em> It is expected that for all pair of vertices there exists a matrix in the <code>lindbladians</code> list.</p><p><em>Note:</em> The orthogonality of matrices in <code>lindbladians</code> is not verified.</p><p><em>Note:</em> The submatrices of the result matrix are multiplied by corresponding <code>A</code> element.</p><p>[1] K. Domino, A. Glos, M. Ostaszewski, Superdiffusive quantum stochastic walk definable on arbitrary directed graph, Quantum Information &amp; Computation, Vol.17 No.11&amp;12, pp. 0973-0986, arXiv:1701.04624.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [0 1 0; 1 0 1; 0 1 0]
3×3 Array{Int64,2}:
 0  1  0
 1  0  1
 0  1  0

julia&gt; L, vset = nm_lind(A)
(
  [2, 1]  =  1.0+0.0im
  [3, 1]  =  1.0+0.0im
  [1, 2]  =  1.0+0.0im
  [4, 2]  =  1.0+0.0im
  [1, 3]  =  1.0+0.0im
  [4, 3]  =  1.0+0.0im
  [2, 4]  =  1.0+0.0im
  [3, 4]  =  -1.0+1.22465e-16im, VertexSet(Vertex[Vertex([1]), Vertex([2, 3]), Vertex([4])]))

julia&gt; B1, B2 = 2*diagm(0=&gt;[1.]), 3*ones(2, 2)
([2.0], [3.0 3.0; 3.0 3.0])

julia&gt; nm_lind(A, Dict{Int,Matrix{Float64}}(1=&gt;B1, 2=&gt;B2))
(
  [2, 1]  =  3.0+0.0im
  [3, 1]  =  3.0+0.0im
  [1, 2]  =  2.0+0.0im
  [4, 2]  =  2.0+0.0im
  [1, 3]  =  2.0+0.0im
  [4, 3]  =  2.0+0.0im
  [2, 4]  =  3.0+0.0im
  [3, 4]  =  3.0+0.0im, VertexSet(Vertex[Vertex([1]), Vertex([2, 3]), Vertex([4])]))

julia&gt; v1, v2, v3 = vlist(vset)
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])

julia&gt; nm_lind(A, Dict{Vertex,Matrix{Float64}}(v1 =&gt; ones(1, 1), v2 =&gt; [2 2; 2 -2], v3 =&gt; 3*ones(1, 1)))[1] |&gt; Matrix
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im  1.0+0.0im   0.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im   2.0+0.0im
 2.0+0.0im  0.0+0.0im  0.0+0.0im  -2.0+0.0im
 0.0+0.0im  3.0+0.0im  3.0+0.0im   0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L155-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.nm_measurement" href="#QSWalk.nm_measurement"><code>QSWalk.nm_measurement</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nm_measurement(probability, vertexset)</code></pre><p>Return joint probability of <code>probability</code>, which is real-valued probability vector according to <code>vertexset</code>.</p><p><em>Note:</em> It is up to user to provide proper probability vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; probability = [0.05, 0.1, 0.25, 0.3, 0.01, 0.20, 0.04, 0.05]
8-element Array{Float64,1}:
 0.05
 0.1
 0.25
 0.3
 0.01
 0.2
 0.04
 0.05

julia&gt; nm_measurement(probability, VertexSet([[1, 4], [2, 3, 5], [6], [7, 8]]))
4-element Array{Float64,1}:
 0.35
 0.36
 0.2
 0.09</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L432-L462">source</a></section><section><div><pre><code class="language-none">nm_measurement(state, vertexset)</code></pre><p>Return joint probability of cannonical measurement of density matrix <code>state</code>, according to <code>vertexset</code>.</p><p><em>Note:</em> It is up to user to provide proper density state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; state = [1/6 0 1/6; 0 2/3 0; 1/6 0 1/6]
3×3 Array{Float64,2}:
 0.166667  0.0       0.166667
 0.0       0.666667  0.0
 0.166667  0.0       0.166667

julia&gt; nm_measurement(state, VertexSet([[1, 3], [2]]))
2-element Array{Float64,1}:
 0.3333333333333333
 0.6666666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L470-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.nm_loc_ham" href="#QSWalk.nm_loc_ham"><code>QSWalk.nm_loc_ham</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nm_loc_ham(vertexset[, hamiltoniansByDegree])</code></pre><p>Return Hamiltonian acting locally on each vertex from <code>vertexset</code> linear subspace. <code>hamiltoniansByDegree</code> is a dictionary <code>Dict{Int, SparseDenseMatrix}</code>, which, for a given dimension of vertex linear subspace, yields a hermitian operator. Only matrices for existing dimensions needs to be specified.</p><p><em>Note:</em> Value of <code>vertexset</code> should be generated by <code>make_vertex_set</code> in order to match demoralization procedure. Numerical analysis suggests, that hamiltonians should be complex valued.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vset = VertexSet([[1, 2], [3, 4]])
VertexSet(Vertex[Vertex([1, 2]), Vertex([3, 4])])

julia&gt; Matrix(nm_loc_ham(vset))
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im
 0.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 0.0+0.0im  0.0+0.0im  0.0-1.0im  0.0+0.0im

julia&gt; A = [1 1im; -1im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; nm_loc_ham(vset, Dict{Int,Matrix{ComplexF64}}(2  =&gt; A))
4×4 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 8 stored entries:
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  0.0-1.0im
  [1, 2]  =  0.0+1.0im
  [2, 2]  =  1.0+0.0im
  [3, 3]  =  1.0+0.0im
  [4, 3]  =  0.0-1.0im
  [3, 4]  =  0.0+1.0im
  [4, 4]  =  1.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L43-L86">source</a></section><section><div><pre><code class="language-none">nm_loc_ham(vertexset[, hamiltoniansByVertex])</code></pre><p>Return Hamiltonian acting locally on each vertex from <code>vertexset</code> linear subspace. <code>hamiltoniansByVertex</code> is a dictionary <code>Dict{Vertex, SparseDenseMatrix}</code>, which, for a given vertex, yields a hermitian operator of the size equal to the dimension of the vertex subspace.</p><p><em>Note:</em> Value of <code>vertexset</code> should be generated by <code>make_vertex_set</code> in order to match demoralization procedure. Numerical analysis suggests, that hamiltonians should be complex valued.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vset = VertexSet([[1, 2], [3, 4]])
VertexSet(Vertex[Vertex([1, 2]), Vertex([3, 4])])

julia&gt; Matrix(nm_loc_ham(vset))
4×4 Array{Complex{Float64},2}:
 0.0+0.0im  0.0+1.0im  0.0+0.0im  0.0+0.0im
 0.0-1.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+1.0im
 0.0+0.0im  0.0+0.0im  0.0-1.0im  0.0+0.0im

julia&gt; A, B = [1 1im; -1im 1], [0 1; 1 0]
(Complex{Int64}[1 + 0im 0 + 1im; 0 - 1im 1 + 0im], [0 1; 1 0])

julia&gt; v1, v2 = vlist(vset)
2-element Array{Vertex,1}:
 Vertex([1, 2])
 Vertex([3, 4])

julia&gt; nm_loc_ham(vset, Dict{Vertex,Matrix{Number}}(v1  =&gt; A, v2  =&gt; B))
4×4 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 6 stored entries:
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  0.0-1.0im
  [1, 2]  =  0.0+1.0im
  [2, 2]  =  1.0+0.0im
  [4, 3]  =  1.0+0.0im
  [3, 4]  =  1.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L98-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.nm_init" href="#QSWalk.nm_init"><code>QSWalk.nm_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nm_init(init_vertices, vertexset)</code></pre><p>Create initial state in the case of the nonmoralizing evolution based on <code>init_vertices</code> of type <code>Vector{Vertex}</code>. The result is a block diagonal matrix, where each block corresponds to vertex from <code>vertexset</code>. The final state represent an uniform probability over <code>nm_measurement</code>.</p><p><em>Note:</em> The function returns sparse matrix with <code>ComplexF64</code> field type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vset = VertexSet([[1], [2, 3, 4], [5, 6, 7], [8, 9]])
VertexSet(Vertex[Vertex([1]), Vertex([2, 3, 4]), Vertex([5, 6, 7]), Vertex([8, 9])])

julia&gt; nm_init(vset[[1, 3, 4]], vset)
9×9 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 6 stored entries:
  [1, 1]  =  0.333333+0.0im
  [5, 5]  =  0.111111+0.0im
  [6, 6]  =  0.111111+0.0im
  [7, 7]  =  0.111111+0.0im
  [8, 8]  =  0.166667+0.0im
  [9, 9]  =  0.166667+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L502-L527">source</a></section><section><div><pre><code class="language-none">nm_init(init_states, vertexset)</code></pre><p>Create initial state in the case of the nonmoralizing evolution based on <code>init_states</code> of type <code>Dict{Vertex, &lt;:AbstractMatrix{&lt;:Number}}</code>. For each given vertex a block from dictionary is used, otherwise zero matrix is chosen. Each matrix from dictionary should be nonnegative and sum of all traces should equal one. The keys of <code>init_vertices</code> should be a vertices from <code>vertexset</code>. Note that matrix from <code>init_states</code> corresponding to vertex <code>v</code> should be of size <code>length(v)</code>×<code>length(v)</code>.</p><p><em>Note:</em> The function returns sparse matrix with <code>ComplexF64</code> field type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vset = VertexSet([[1], [2, 3, 4], [5, 6, 7], [8, 9]])
VertexSet(Vertex[Vertex([1]), Vertex([2, 3, 4]), Vertex([5, 6, 7]), Vertex([8, 9])])

julia&gt; A1, A2, A3 = ones(ComplexF64, 1, 1)/4, [ 1/5+0im 0 1/5; 0 1/10 0 ; 1/5 0 1/5 ], [0.125 -0.125+0im; -0.125 0.125]
(Complex{Float64}[0.25 + 0.0im], Complex{Float64}[0.2 + 0.0im 0.0 + 0.0im 0.2 + 0.0im; 0.0 + 0.0im 0.1 + 0.0im 0.0 + 0.0im; 0.2 + 0.0im 0.0 + 0.0im 0.2 + 0.0im], Complex{Float64}[0.125 + 0.0im -0.125 + 0.0im; -0.125 + 0.0im 0.125 + 0.0im])

julia&gt; nm_init(Dict(vset[1] =&gt;A1, vset[3] =&gt;A2, vset[4] =&gt;A3), vset)
9×9 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 10 stored entries:
  [1, 1]  =  0.25+0.0im
  [5, 5]  =  0.2+0.0im
  [7, 5]  =  0.2+0.0im
  [6, 6]  =  0.1+0.0im
  [5, 7]  =  0.2+0.0im
  [7, 7]  =  0.2+0.0im
  [8, 8]  =  0.125+0.0im
  [9, 8]  =  -0.125+0.0im
  [8, 9]  =  -0.125+0.0im
  [9, 9]  =  0.125+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L540-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.default_nm_loc_ham" href="#QSWalk.default_nm_loc_ham"><code>QSWalk.default_nm_loc_ham</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_nm_loc_ham(size)</code></pre><p>Return default local Hamiltonian of size <code>size</code>×<code>size</code> for the demoralization procedure. The Hamiltonian is sparse with nonzero elements on the first upper diagonal (equal to <code>1im</code>) and lower diagonal (equal to <code>-1im</code>).</p><p><em>Note:</em> This function is used to provide the default argument for <code>nm_loc_ham</code> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; QSWalk.default_nm_loc_ham(4)
4×4 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 6 stored entries:
  [2, 1]  =  0.0-1.0im
  [1, 2]  =  0.0+1.0im
  [3, 2]  =  0.0-1.0im
  [2, 3]  =  0.0+1.0im
  [4, 3]  =  0.0-1.0im
  [3, 4]  =  0.0+1.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/demoralization.jl#L10-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.make_vertex_set" href="#QSWalk.make_vertex_set"><code>QSWalk.make_vertex_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_vertex_set(A[, epsilon])</code></pre><p>Creates object of type <code>VertexSet</code> which represents how vertices are located in matrix. Should be used only in the nondefault use of <code>evolve_generator</code> function. It is always equal to the second element if output of <code>evolve_generator</code> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2 3; 0 3. 4.; 0 0 5.]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 0.0  3.0  4.0
 0.0  0.0  5.0

julia&gt; vlist(make_vertex_set(A))
3-element Array{Vertex,1}:
 Vertex([1, 2, 3])
 Vertex([4, 5])
 Vertex([6])

julia&gt; vlist(make_vertex_set(A, epsilon = 2.5))
3-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3])
 Vertex([4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/utils.jl#L257-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.vlist" href="#QSWalk.vlist"><code>QSWalk.vlist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vlist(vset)</code></pre><p>Returns the list of vertices for given <code>vset</code> of type <code>VertexSet</code>.</p><pre><code class="language-julia-repl">julia&gt; vset = VertexSet([[1], [2, 3, 4], [5, 6, 7], [8, 9]])
VertexSet(Vertex[Vertex([1]), Vertex([2, 3, 4]), Vertex([5, 6, 7]), Vertex([8, 9])])

julia&gt; vlist(vset)
4-element Array{Vertex,1}:
 Vertex([1])
 Vertex([2, 3, 4])
 Vertex([5, 6, 7])
 Vertex([8, 9])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/utils.jl#L104-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.subspace" href="#QSWalk.subspace"><code>QSWalk.subspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">subspace(v)</code></pre><p>Returns the subspace connected to vertex <code>v</code>.</p><pre><code class="language-julia-repl">julia&gt; v = Vertex([1,2,3])
Vertex([1, 2, 3])

julia&gt; subspace(v)
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/utils.jl#L48-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.fourier_matrix" href="#QSWalk.fourier_matrix"><code>QSWalk.fourier_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fourier_matrix(size)</code></pre><p>Returns Fourier matrix of size <code>size</code>×<code>size</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fourier_matrix(1)
1×1 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 1 stored entry:
  [1, 1]  =  1.0+0.0im

julia&gt; fourier_matrix(2)
2×2 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  1.0+0.0im
  [1, 2]  =  1.0+0.0im
  [2, 2]  =  -1.0+1.22465e-16im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/dirac.jl#L189-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QSWalk.vertexsetsize" href="#QSWalk.vertexsetsize"><code>QSWalk.vertexsetsize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertexsetsize(vertexset)</code></pre><p>Return the dimension of the linearspace corresponding to given <code>vertexset</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; vertexsetsize(VertexSet([[1, 2, 3], [4, 5]]))
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/iitis/QSWalk.jl/blob/f2bc8884e61acf137576f832a12575d462fe3696/src/utils.jl#L129-L140">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gksl/">« GKSL master equation</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 24 February 2020 10:56">Monday 24 February 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
